(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.Pale = factory());
}(this, (function () { 'use strict';

  /**
   * Validators consist of pure functions.
   * Those functions always return a boolean
   * true = validation passed
   * false = validation error
   */

  const validators = {
    string(value) {
      return !/[\d]+/g.test(value);
    },
    number(value) {
      if (!value) return false;
      return !/[\D]+/g.test(value);
    },
    min(value, size) {
      if (isNaN(+value)) return false;
      if (isNaN(+size)) return false;
      return +value >= +size;
    },
    max(value, size) {
      if (isNaN(+value)) return false;
      if (isNaN(+size)) return false;
      return +value <= +size;
    },
    minLength(value, size) {
      if (!value) return false;
      if (isNaN(+size)) return false;
      return value.length >= +size;
    },
    maxLength(value, size) {
      if (!value) return false;
      if (isNaN(+size)) return false;
      return value.length <= +size;
    }
  };

  class Pale {
    constructor(validationList) {
      this.validationList = validationList;
      this.validatorsList = validators;
    }

    get validators() {
      return this.validatorsList;
    }

    set validators(validators$$1) {
      this.validatorsList = validators$$1;
    }

    run() {
      return new Promise((resolve, reject) => {
        const validators$$1 = Object.keys(this.validationList);
        const recipe = [];

        validators$$1.forEach((validator) => {
          recipe.push(this.extractRules(this.validationList[validator]));
        });

        const recipeResults = this.runRepice(recipe);
      });
    }

    extractRules(validationItem) {
      let rules = validationItem[0].split(' ');

      rules = rules
        .map(rule => {
          return {
            rule: rule.replace(/\([0-9]\)/, ''),
            value: ((rule.match(/\(([0-9]{1,})\)/g) || [''])[0].replace(/[\(\)]/g, '') || false)
          }
        });

      return {
        rules: rules,
        parameter: validationItem[1],
        element: validationItem[2]
      }
    }

    runRepice(recipe) {
      recipe.forEach((recipeItem) => {
        const value = recipeItem.parameter;
        let validationStatus = true;

        recipeItem.rules.forEach((rule, i) => {
          if (!this.validators[rule.rule]) {
            throw `Could not find validator ${rule.rule} in validators list.`;
          }
          const ruleResult = this.validators[rule.rule](value, rule.parameter);
          recipeItem.rules[i].status = ruleResult;

          if (!ruleResult) validationStatus = false;
        });
        
        recipe.validationStatus = validationStatus;
      });
    }

    addValidator(newValidator) {
      if (!newValidator || {}.toString.call(newValidator) !== '[object Function]') {
        throw `.addValidator() expects a function, ${typeof validator} given.`;
      }

      const validatorList = this.validators;

      this.validationList[newValidator.name] = newValidator;
    }
  }

  return Pale;

})));
